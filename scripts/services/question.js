//~ Question Services
'use strict';

var module = angular.module('service.question', ['qc-config']);

module.service('QuestionModel', ['$http', '$q', 'Authuser', 'NotificationsService', 'apiConfig', function($http, $q, Authuser, NotificationsService, apiConfig) {
	var apiRootLocation = apiConfig.rootLocation,
		self = this,
		// Functions that should be attached to question instances generated by get and list
		addTags = function(tags) {
			var deferred = $q.defer(),
				me = this,
				tempTags = this.tags;

			this.tags = this.tags.union(tags);

			self.addTags({
				'id': this.id,
				'tags': tags
			}).then(function(data) {
				deferred.resolve(data);
			}, function(reason) {
				NotificationsService.push({
					title: 'Error!',
					message: 'Sorry, there has been an error connecting to the server.',
					type: 'error'
				});

				me.tags = tempTags;
				deferred.reject(reason);
			});

			return deferred.promise;
		},
		removeTags = function(tags) {
			var deferred = $q.defer(),
				me = this,
				tempTags = this.tags;

			this.tags = this.tags.subtract(tags);

			self.removeTags({
				'id': this.id,
				'tags': tags
			}).then(function(data) {
				deferred.resolve(data);
			}, function(reason) {
				NotificationsService.push({
					title: 'Error!',
					message: 'Sorry, there has been an error connecting to the server.',
					type: 'error'
				});

				me.tags = tempTags;
				deferred.reject(reason);
			});

			return deferred.promise;
		};

	// List of params: course_id, semester_id, location, limit, pageNum
	this.list = function(params) {
		var deferred = $q.defer(),
			queryArr = [];

		if (!angular.isUndefined(params.course_id) && null !== params.course_id) {
			queryArr.push('course_id=' + params.course_id);
		}

		if (!angular.isUndefined(params.semester_id) && null !== params.semester_id) {
			queryArr.push('semester_id=' + params.semester_id);
		}

		queryArr.push('limit=' + params.limit);
		queryArr.push('offset=' + (params.pageNum - 1) * params.limit);
		queryArr.push('location=' + params.location);

		$http.get(apiRootLocation + 'question?' + queryArr.join('&')).success(function(questionList) {
			deferred.resolve({
				'questions':        questionList.questions.each(function(q) {
										q.addTags = addTags;
										q.removeTags = removeTags;
									}),
				'totalQuestions':   questionList.total_questions,
				'totalPages':       Math.ceil(questionList.total_questions / params.limit),
				'pageNum':          parseInt(params.pageNum, 10),
				'count':            questionList.count,
				'limit':            params.limit,
				'course_id':        params.course_id,
				'semester_id':      params.semester_id,
				'location':         params.location
			});
		}).error(function(data) {
			deferred.reject(data);
		});

		return deferred.promise;
	};

	this.get = function(params) {
		var deferred = $q.defer();

		$http.get(apiRootLocation + 'question/' + params.id).success(function(question) {
			question.addTags = addTags;
			question.removeTags = removeTags;
			deferred.resolve(question);
		}).error(function(data) { deferred.reject(data); });

		return deferred.promise;
	};


	this.update = function(params) {
		mixpanel.track('lecturer: update question', {
			id: params.id,
			user_id: Authuser.id,
			course_id: params.question.course_id,
			semester_id: params.question.semester_id
		});
		return $http.post(apiRootLocation + 'question/' + params.id + '/update', params.question);
	};

	this.create = function(params) {
		mixpanel.track('lecturer: create question', {
			user_id: Authuser.id,
			course_id: params.question.course_id,
			semester_id: params.question.semester_id
		});
		params.question.user_id = Authuser.id;
		return $http.post(apiRootLocation + 'question/create', params.question);
	};


	this.close = function(params) {
		return $http.post(apiRootLocation + 'question/close', params.ids);
	};

	this.open = function(params) {
		return $http.post(apiRootLocation + 'question/open', params.ids);
	};

	this.copy = function(params) {
		mixpanel.track('lecturer: copy questions', {
			user_id: Authuser.id,
			course_id: params.courseId,
			semester_id: params.semesterId,
			ids: params.ids
		});
		return $http.post(apiRootLocation + 'question/copy', {
			'ids': params.ids,
			'course_id': params.courseId,
			'semester_id': params.semesterId
		});
	};

	this.trash = function(params) {
		return $http.post(apiRootLocation + 'question/archive', params.ids);
	};

	this['delete'] = function(params) {
		return $http.post(apiRootLocation + 'question/delete', params.ids);
	};

	this.restore = function(params) {
		return $http.post(apiRootLocation + 'question/restore', params.ids);
	};

	this.addTags = function(params) {
		return $http.post(apiRootLocation + 'question/' + params.id + '/tag/add', {'tags': params.tags});
	}

	this.removeTags = function(params) {
		return $http.post(apiRootLocation + 'question/' + params.id + '/tag/remove', {'tags': params.tags});
	}
}]);



/**
*   The idea behind this factory is to be a singleton interface to the pages of, as well as individiual, questions. This
*   when you want to do work, you call a function to return a reference. The state of the singleton changes and all the
*   'operating' functions will work with this state. Thus, caching and unification of messages, etc, can be done in this
*   factory.
*/
module.factory('QuestionService', ['$http', '$q',  '$cacheFactory', 'QuestionModel', 'NotificationsService', function($http, $q, $cacheFactory, QuestionModel, NotificationsService) {
	var emptyId = 'empty',
		extend = angular.extend,
		isUndefined = angular.isUndefined,
		questionPageCache = $cacheFactory.get('questionPageCache') || $cacheFactory('questionPageCache', {'capacity': 20}),
		questionCache = $cacheFactory.get('questionCache') || $cacheFactory('questionCache', {'capacity': 20}),
		calcHash = function(params) {
			return 'a:' + params.course_id + 'b:' + params.semester_id + 'c:' +
				params.pageNum + 'd:' + params.location + 'e:' + params.limit;
		},
		// The following function is used to update things that dont need a reload, ie opening/closing a question
		updateWithoutReload = function(loadMessage, successMessage, errorMessage, currentPage, property, propertyNewVal, functionToCall) {
			var deferred = $q.defer();

			if (currentPage) {
				var selectedQuestions = currentPage.questions.filter(function(question) { return question.selected; });

				if (selectedQuestions.length > 0) {
					NotificationsService.push({
						title: 'Loading...',
						message: loadMessage,
						type: 'alert'
					});

					var ids = selectedQuestions.map(function(question) { return question.id; });

					functionToCall({'ids': ids}).then(function() {
						selectedQuestions.each(function(question) {
							question[property] = propertyNewVal;
							question.selected = false;
						});

						NotificationsService.push({
							title: 'Success!',
							message: successMessage,
							type: 'success'
						});

						deferred.resolve(currentPage);
					}, function(reason) {
						NotificationsService.push({
							title: 'Error!',
							message: errorMessage,
							type: 'error'
						});

						deferred.reject();
					});
				}
			} else {
				deferred.reject();
			}

			return deferred.promse;
		},
		updateWithReload = function(loadMessage, successMessage, errorMessage, currentPage, functionToCall, functionToLoad) {
			var deferred = $q.defer(),
				showError = function() {
					NotificationsService.push({
						title: 'Error!',
						message: errorMessage,
						type: 'error'
					});
				};

			if (currentPage) {
				var selectedQuestions = currentPage.questions.filter(function(question) { return question.selected; });

				if (selectedQuestions.length > 0) {
					NotificationsService.push({
						title: 'Loading...',
						message: loadMessage,
						type: 'alert'
					});

					var ids = selectedQuestions.map(function(question) { return question.id; });

					functionToCall({'ids': ids}).then(function() {
						functionToLoad(currentPage).then(function(questionsPage) {
							NotificationsService.push({
								title: 'Success!',
								message: successMessage,
								type: 'success'
							});
							
							extend(currentPage, questionsPage);
							deferred.resolve(currentPage);
						}, function(reason) {
							showError();
							deferred.reject(reason);
						});
					}, function(reason) {
						showError();
						deferred.reject(reason);
					});
				}
			} else {
				deferred.reject();
			}

			return deferred.promise;
		},
		QuestionService;

	QuestionService = {

		/**
		*  The following method returns an object that represents a cached or empty questionpage. An ajax request is then
		*  made and the object is updated with the latest question without the reference being destroyed.
		*
		*       getQuestionsPage(params)
		*   
		*   Following require the questions in the questions page to have question.selected property
		*
		*       openSelected()
		*       closeSelected()
		*       copySelected()
		*       trashSelected()
		*       restoreSelected()
		*       deleteSelected()
		*/

		// List of params: course_id, semester_id, pageNum, orderBy, filterBy
		getQuestionsPage: function(params) {
			params.location = (!angular.isUndefined(params.location) && null !== params.location) ? params.location : 'list';
			params.limit = (!angular.isUndefined(params.limit) && null !== params.limit) ? params.limit : 20;
			params.pageNum = (!angular.isUndefined(params.pageNum) && null !== params.pageNum) ? parseInt(params.pageNum, 10) : 1;

			var hash = calcHash(params),
				cache = questionPageCache.get(hash) || {},
				notification = {
					title: 'Loading...',
					message: '',
					type: 'alert'
				};

			NotificationsService.push(notification);

			QuestionModel.list(params).then(function(questionsPage) {
				questionPageCache.put(hash, questionsPage);
				extend(cache, questionsPage);
				notification.remove();
			});

			return cache;
		},

		openSelected: function(currentPage) {
			var loadMessage = 'Opening selected question(s).',
				successMessage = 'Selected questions <strong>opened</strong>.',
				errorMessage = 'Sorry, there has been an error, please try again.',
				property = 'open',
				propertyNewVal = true,
				functionToCall = QuestionModel.open;

			return updateWithoutReload(loadMessage, successMessage, errorMessage, currentPage, property, propertyNewVal, functionToCall);
		},

		closeSelected: function(currentPage) {
			var loadMessage = 'Closing selected question(s).',
				successMessage = 'Selected questions <strong>closed</strong>.',
				errorMessage = 'Sorry, there has been an error, please try again.',
				property = 'open',
				propertyNewVal = false,
				functionToCall = QuestionModel.close;

			return updateWithoutReload(loadMessage, successMessage, errorMessage, currentPage, property, propertyNewVal, functionToCall);
		},

		copySelected: function(currentPage, options) {
			var loadMessage = 'Copying selected question(s).',
				successMessage = 'Selected questions <strong>copied</strong>.',
				errorMessage = 'Sorry, there has been an error, please try again.',
				functionToCall = function(params) {
					extend(params, {
						'courseId': options.courseId,
						'semesterId': options.semesterId
					});
					return QuestionModel.copy(params);
				},
				functionToLoad = QuestionModel.list;

			return updateWithReload(loadMessage, successMessage, errorMessage, currentPage, functionToCall, functionToLoad);
		},

		trashSelected: function(currentPage) {
			var loadMessage = 'Moving selected question(s) to the <strong>Bin</strong>.',
				successMessage = 'Selected questions moved to the <strong>Bin</strong>.',
				errorMessage = 'Sorry, there has been an error, please try again.',
				functionToCall = QuestionModel.trash,
				functionToLoad = QuestionModel.list;

			return updateWithReload(loadMessage, successMessage, errorMessage, currentPage, functionToCall, functionToLoad);
		},

		deleteSelected: function(currentPage) {
			var loadMessage = 'Permanently deleting questions.',
				successMessage = 'Selected questions deleted permanently.',
				errorMessage = 'Sorry, there has been an error, please try again.',
				functionToCall = QuestionModel['delete'],
				functionToLoad = QuestionModel.list;

			return updateWithReload(loadMessage, successMessage, errorMessage, currentPage, functionToCall, functionToLoad);
		},

		restoreSelected: function(currentPage) {
			var loadMessage = 'Restoring selected questions.',
				successMessage = 'Selected questions restored.',
				errorMessage = 'Sorry, there has been an error, please try again.',
				functionToCall = QuestionModel.restore,
				functionToLoad = QuestionModel.list;

			return updateWithReload(loadMessage, successMessage, errorMessage, currentPage, functionToCall, functionToLoad);
		},

		/**
		*  The following method returns an object reference to single question. It returns a cached object and then 
		*  updates it asyncronusly.
		*
		*    getQuestion(id)
		*
		*  Once you have a reference to a question from above, you can modify this question and then call the following
		*  function to save that question.
		*
		*    saveQuestion()
		*/

		getQuestion: function(id) {
			if(isUndefined(id) || null === id) {
				id = emptyId;
			} else {
				id = parseInt(id, 10);
			}

			var blankQuestion = {
					id: null,
					max_responses: 0,
					hidden: false,
					open: true,
					options: [
						{},
						{}
					]
				},
				cache = questionCache.get(id) || blankQuestion;

			if(id === emptyId) {
				questionCache.put(id, cache);
			} else {
				QuestionModel.get({'id': id}).then(function(question) {
					questionCache.put(id, question);
					extend(cache, question);
				});
			}

			return cache;
		},

		saveQuestion: function(inputQuestion) {
			var deferred = $q.defer();

			NotificationsService.push({
				title: 'Loading...',
				message: 'Saving question.',
				type: 'alert'
			});

			if(null === inputQuestion.id || isUndefined(inputQuestion.id)) {
				QuestionModel.create({'question': inputQuestion}).then(function(response) {
					var question = response.data;

					questionCache.remove(emptyId); // remove the entry for the blank question in the cache
					questionCache.put(parseInt(question.id, 10), question);

					NotificationsService.push({
						title: 'Success!',
						message: 'Question successfully <strong>created</strong>.',
						type: 'success'
					});

					deferred.resolve(questionCache.get(parseInt(question.id, 10)));
				}, function(reason) {
					deferred.reject(reason);
				});
			} else {
				QuestionModel.update({
					'id': inputQuestion.id,
					'question': inputQuestion
				}).then(function(response) {
					var question = response.data;

					questionCache.put(parseInt(question.id, 10), question);

					NotificationsService.push({
						title: 'Success!',
						message: 'Question successfully <strong>updated</strong>.',
						type: 'success'
					});

					deferred.resolve(questionCache.get(parseInt(question.id, 10)));
				}, function(reason) {
					deferred.reject(reason);
				});
			}

			return deferred.promise;
		},

		openQuestion: function(inputQuestion) {
			var deferred = $q.defer();

			NotificationsService.push({
				title: 'Loading...',
				message: 'Opening question.',
				type: 'alert'
			});

			QuestionModel.open({'ids': [inputQuestion.id]}).then(function() {
				inputQuestion.open = true;
				questionCache.put(inputQuestion.id, inputQuestion);
				NotificationsService.push({
					title: 'Success!',
					message: 'Question is now <strong>open</strong>.',
					type: 'success'
				});
				deferred.resolve(questionCache.get(inputQuestion.id));
			}, function(reason) {
				deferred.reject(reason);
			});

			return deferred.promise;
		},

		closeQuestion: function(inputQuestion) {
			var deferred = $q.defer();

			NotificationsService.push({
				title: 'Loading...',
				message: 'Closing question.',
				type: 'alert'
			});

			QuestionModel.close({'ids': [inputQuestion.id]}).then(function() {
				inputQuestion.open = false;
				questionCache.put(inputQuestion.id, inputQuestion);
				NotificationsService.push({
					title: 'Success!',
					message: 'Question is now <strong>closed</strong>.',
					type: 'success'
				});
				deferred.resolve(questionCache.get(inputQuestion.id));
			}, function(reason) {
				deferred.reject(reason);
			});

			return deferred.promise;
		}
	};

	return QuestionService;
}]);
